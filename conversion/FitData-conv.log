--- FitData.py	(original)
+++ FitData.py	(refactored)
@@ -803,8 +803,8 @@
             dTab = os.path.join(PathToData, tName)
             # If both filetypes exist, opt for .csv file
             if os.path.isfile(dCsv) and os.path.isfile(dTab):
-                print "  Warning: Both %s.csv and %s.tab files exist." % (Name, Name)
-                print "           %s.csv will be used." % Name
+                print("  Warning: Both %s.csv and %s.tab files exist." % (Name, Name))
+                print("           %s.csv will be used." % Name)
                 dPath = dCsv
             elif os.path.isfile(dCsv) and not os.path.isfile(dTab):
                 dPath = dCsv
@@ -1013,7 +1013,7 @@
                 # If value given is <100, assume its in oC and convert
                 if self.te < 100.:
                     self.te = self.te + 273.15
-                    print "Assuming %s in centigrade, converting to %sK.\n" % (inp[1], self.te)
+                    print("Assuming %s in centigrade, converting to %sK.\n" % (inp[1], self.te))
             # Set magnetization alignment
             elif "alignmag" in pName.lower():
                 self.AlignMag = inp[1].lower()
@@ -1035,8 +1035,8 @@
                     # Percentage of data to remove
                     self.deldata = float(inp[1])
                 except ValueError:
-                    print "Incorrect percentage assigned to be randomly removed."
-                    print "Ignoring flag and using all data in fit."
+                    print("Incorrect percentage assigned to be randomly removed.")
+                    print("Ignoring flag and using all data in fit.")
             else:
                 # Assign initial value for given parameter
                 self.Pars[pName][0] = float(inp[1])
@@ -1333,7 +1333,7 @@
     def MapGlobalP0(self):
         # Create a list of all the dictionary keys for
         #  each global object self.Pars dict
-        self.gKeys = [x.Pars.keys() for x in self.gObs]
+        self.gKeys = [list(x.Pars.keys()) for x in self.gObs]
 
         # Flatten to 1D and include only those within the gVar dictionary
         self.gKeys = [x for x in list(it.chain.from_iterable(self.gKeys)) if x.split("_")[0] in self.gVar]
@@ -1465,7 +1465,7 @@
         # Update ob.Pars[key][New Val] with value from
         #  Params array (by way of tdict). These are the
         #  updated fitted values
-        for key in ob.Pars.keys():
+        for key in list(ob.Pars.keys()):
             if key in tdict:
                 ob.Pars[key][5] = tdict[ob.Pars[key][4]]
             elif key in self.gShared:
@@ -1476,7 +1476,7 @@
                 ob.Pars[key][5] = ob.Pars[key][0]
 
         # For fixed R1b/c and R2b/c values, set equal to R1 and R2 if they are 0.0
-        for key in ob.Pars.keys():
+        for key in list(ob.Pars.keys()):
             if key in self.gFixed and "R1b" in key or "R1c" in key and ob.Pars[key][0] == 0.0:
                 ob.Pars[key][5] = ob.Pars["R1_%s" % ob.FitNum][5]
             elif key in self.gFixed and "R2b" in key or "R2c" in key and ob.Pars[key][0] == 0.0:
@@ -1507,7 +1507,7 @@
         # Update ob.Pars[key][New Val] with value from
         #  Params array (by way of tdict). These are the
         #  updated fitted values
-        for key in ob.Pars.keys():
+        for key in list(ob.Pars.keys()):
             if key in tdict:
                 ob.Pars[key][6] = tdict[ob.Pars[key][4]]
             elif key in self.gShared:
@@ -1518,7 +1518,7 @@
                 ob.Pars[key][6] = ob.Pars[key][0]
 
         # For fixed R1b/c and R2b/c values, set equal to R1 and R2 if they are 0.0
-        for key in ob.Pars.keys():
+        for key in list(ob.Pars.keys()):
             if key in self.gFixed and "R1b" in key or "R1c" in key and ob.Pars[key][0] == 0.0:
                 ob.Pars[key][6] = ob.Pars["R1_%s" % ob.FitNum][6]
             elif key in self.gFixed and "R2b" in key or "R2c" in key and ob.Pars[key][0] == 0.0:
@@ -1615,7 +1615,7 @@
                 try:
                     self.FitLoops = int(i[1])
                 except ValueError:
-                    print "Number of fit loops is not an integer, setting to 1 loop."
+                    print("Number of fit loops is not an integer, setting to 1 loop.")
             elif "randomfitstart" in i[0].lower():
                 if "y" in i[1].lower():
                     self.rndStart = True
@@ -1904,4 +1904,4 @@
             ob.mcFits[loopNum].update({'RedChiSq' : redChiSq, 'AlignMag' : ob.AlignMag,
                                        'lf' : ob.lf, 'Temp': ob.te})
         # Reset gAllD just to be certain
-        self.gAllD = {x:0. for x in self.gAllD.keys()}
+        self.gAllD = {x:0. for x in list(self.gAllD.keys())}
